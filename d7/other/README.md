# Основное
https://www.youtube.com/watch?v=F0jYQdTEJEo&list=PLzPivwyXljVWyIN-AuV1j-9XHR_b4mf9k&index=5  
ООП PHP: https://www.youtube.com/watch?v=gbhFXNcxAYQ  
Git и PhpStorm: https://www.youtube.com/watch?v=9TJEoYnnEUU&list=PLd2_Os8Cj3t_NscvtE9xd0QATeYy-kNCU  

- новый подход к API
- всё стандартизовано
- появилось ORM
- ядро основано на принципах ООП

D7 это не просто новый варинат записи старых методов, это своя идеология, свои принципы работы, поэтому не всегда можно напрямую заменить старый метод на вызов нового.

Пока еще не ввсё старое ядро переписано на D7 и не все модули и классы его поддерживают, например класс CUser (bitrix/modules/main/lib/user.php - прокрутить вниз к методам add, update, delete): https://dev.1c-bitrix.ru/api_help/main/reference/cuser/index.php, теперь доступен в D7: https://dev.1c-bitrix.ru/api_d7/bitrix/main/usertable/index.php

## Файлы
- .settings.php - настройка ядра D7
- /local/ - отделяем файлы с пользовательским кодом от кода ядра Битрикс
- компоненты на классах (теперь можно их не кастомизировать, а наследовать)

## Пример с языковыми файлами
Пример с подключением языкового файла `IncludeTemplateLangFile(__FILE__)` (старое ядро):

    \Bitrix\Main\Localization\Loc::loadMessages(__FILE__); // подключаем метод сразу с полным путем

Если мы в коде будем использовать метод `loadMessages()` или методы класса `Loc` более одного раза, то можно путь разместить вверху кода и далее в коде обращаться уже к `Loc`:

    use \Bitrix\Main\Localization\Loc;
    Loc::loadMessages(__FILE__);

Можно переименовать:

    use \Bitrix\Main\Localization\Loc as Loc2;
    Loc::loadMessages(__FILE__);

В коде `<?=GetMessage('CFT_MAIN')?>` меняем на `<?=Loc::getMessage('CFT_MAIN')?>`.

## Настройка ядра
- настройка подключения к базе данных
- настройка кеширования
- и прочее

Для старого ядра файл настройки Битрикс располагается в `/bitrix/php_interface/dbconn.php`.  
Для нового ядра D7 файл настройки Битрикс в `/bitrix/.settings.php`.  
Эти два файла используются одновременно.  

Параметры файла .settings.php позволяет редактировать API `Bitrix\Main\Config`:
- секции можно создавать самому, с параметрами которые нужны вам и вашему сайту,
- есть три основные секции
  - секция `caсhe` (отвечает за настрйоки кеширования)
    - type может быть: files, memcache, apc, xcache, none 
  - секция `exception_handling` (отвечает за обработку ошибок)
  - секция `connections` (задаёт параметры соединения с базой данных и другими источниками данных)
- секции это массивы

## Папка local
- содержит основные файлы проекта, раньше они хранились в папке bitrix
  - изолирует файлы проекта от папки продукта
- удобно при работе с ситемой контроля версий, благодаря папке local в исключения можно добавить только папку bitrix

local/
- activities/    - действия бизнес процесса
- components/    - компоненты bitrix и пользовательские (в своём пространстве имён)
  - bitrix/
  - usercomponent/
    - class/
  - companyname/
- gadgets/       - гаджеты рабочего стола
- modules/       - модули
- php_interface/ - 
  - user_lang/   - 
  - init.php     - 
- templates/     - 
  - шаблоны сайтов
  - шаблоны компонентов
  - шаблоны страниц

У папки `local`, приоритет выше чем у папки `bitrix`.  
Можно скопировать в своё пространство комопнент битрикса и кастомизировать его.

components/companyname/
- class/
  - images/
  - templates/
  - .description.php
  - .parameters.php
  - class.php

Шаблоны компонентов размещаются в текущем шаблона сайта, в шаблоне по-умолчанию `.default`, в папке шаблонов самого компонента.

Штатные модули битрикса размещаются в папке `bitrix/modules`. Свои модули помещаем в `local/modules/firm.name` данный модуль покажется в админке. При разработке модулей для маркетплейса, нужно учитывать что они будут устанавливаться в папку `bitrix/modules`.

## Компоненты на классах
https://hmarketing.ru/blog/bitrix/sozdanie-prostogo-komponenta-v-d7/

Компоненты на классах, это:
- структурированный код,
- возможность наследования компонентов

Раньше компоненты Битрикса копировали в своё пространство имён и изменяли под проект. Сейчас компоненты можно наследовать, переопределять нужные методы или добавить свои.

Раньше писали `component.php` сейчас `class.php`:

local/components/compname/
- class/
  - images/
  - templates/
    - .default/template.php
  - .description.php
  - .parameters.php
  - class.php

Простой пример кода в файле class.php, класс `classComponents` наследуется от `CBitrixComponent`  
CBitrixComponent: https://dev.1c-bitrix.ru/api_help/main/reference/cbitrixcomponent/index.php

    class classComponent extends CBitrixComponent {

      // методф фомирует массив данных
      function var1() {
        $arResult['var1'] = 'Отработал метод var1 компонента class.';
        return $arResult;
      }

      // Запускается при выполнении компонента
      public function executeComponent() {
        $this->arResult = array_merge( $this->arResult, $this->var1() );
        // Подключает шаблон
        $this->includeComponentTemplate();
      }
    }

- classComponent - имя компонента, произвольное
- executeComponent() - обязательный метод, аналог конструктора

local/components/compname/templates/.default/template.php выводим данные компонента на сайте:

    if(!defined("B_PROLOG_INCLUDED") || B_PROLOG_INCLUDED!==true) die();
    echo '<pre>';
    var_dump($arResult);
    echo '</pre>';

### Наследуем пользовательский компонент
Создаём компонент `local/components/compname/class.extends/`, который будет наследоваться теперь от нашего компонента:

Эти файлы и папки внутри `class.extends` не наследуются, их нужно создать или скопировать:
- images/
- templates/
- .description.php
- .parameters.php
- class.php

Код:

    // Передаём имя компонента от которого будем наследоваться
    CBitrixComponent::includeComponentClass("compname:class");
    class classComponentExtends extends classComponent {
      function var2() {
        $arResult['var2'] = 'Отработал метод var2 компонента class.';
        return $arResult;
      }
      // Переопределяем метод
      public function executeComponent() {
        $this->arResult = array_merge( $this->arResult, $this->var2() );
        parent::executeComponent();
      }
    }

В executeComponent() добавляем код который будет расширять родительский метод или пишем свой с нуля.

## Пространства имён
Пространства имён (namespace):
- глобальное пространство: основной код скрипта
- локальное пространство: код внутри функции
- пространство с именем A: класс А метод класса А
- пространство с именем B: класс А метод класса А

Все классы ядра Битрикс, находятся в пространстве имён Битрикс и не пересекаются ни с PHP ни с пользовательской разработкой. Каждый стандартный модуль определяет в пространстве имён Битрикс своё подпространство совпадающее с именем модуля:
- forum: `Bitrix\Forum`,
- main: `Bitrix\Main`

Если нужно класс поместить в простарнство имён, то в самом вверху файла указываем это простарнство:

    namespace Academy\Oop;

    class className {
      ...
      public function GetPatch() {
        ...
      }
      ...
    }

Вызываем метод GetPatch(), сначала пишем путь пространства имён, далее класс и метод:

    Academy\Oop\className::GetPatch()

Используем синонимы вместо длинных имён пространства имён:

    use \Academy\Oop\className;
    className::GetPatch();

Создаём свой синоним для класса:

    use \Academy\Oop\className as cn;
    cn::GetPatch();

Это делается либо для сокращения имени класса или если у вас в файле вызываются два класса с одинаковыми именами, но из разных пространств:

    use \Bitrix\Main\Localization\Loc;
    use \Academy\Oop\Loc;

## Модули
Битрикс модульная система. Модули делятся на:
- штатные модули (ядро системы),
- сторонние решения (модули из маркетплейса).

Модули и D7:
- новое API для работы с модулем, методы обслуживающие работу модуля
- папка `lib` и подпапки, здесь помещают классы и методы модуля
- автозагрузка (autoload), автоматическая загрузка классов и методов размещённых в папке `lib`:
  - каждый класс должен находится в отдельном файле,
  - имя класса должно совпадать с именем файла,

CopyDirFiles(), DeleteDirFilesEx(), IncludeAdminFile() пока не имеют аналогов в D7.

Пространство имени модуля `local/modules/academy.oop`:
- имя модуля `academy.oop` название папки
- все файлы с классами лежащими в папке `lib`, должны начинаться с `namespace Academy\Oop;`, где Academy это имя партнёра (имя разработчика модуля), Oop это имя самого модуля.

Допустим создаём папку `local/modules/academy.oop/lib/components/` куда поместим код для компонентов, если там создадим класс, то его namespace будет `namespace Academy\Oop\components;`

### Задаём автозагрузку самостоятельно
Отступать от правил наименования пространства имён, категорически запрешается, если вы пишете с нуля. Но если вы работаете с чужим кодом, где правила наименования классов нарушены, например имя файла и имя класса не совпадают или в фале вместо одного класса несколько, то нужно сделать следующее.

Принудительно добавляем методы в автозагрузку:
- например в файле old.php размещены два класса `globalMenu`, `tempModule`,
- эти два класса автоматически подгружаться не будут.

Чтобы они подгружались, в файле `include.php` прописываем:

\Bitrix\Main\Loader::registerAutoLoadClasses('academy.oop', array(
  '\Academy\Oop\globalMenu' => 'lib/old.php'
));

- \Academy\Oop\globalMenu - указываем имя класса
- lib/old.php - путь до файла где содержится класс

## Правила написания кода
Сущесвуют как для старого кода так и для D7.  
Новые единые правила форматирования кода: см в документации Битрикса.

## Отказ от глобальных переменных
Отказ от работы с глобальными переменными.  
При работе со старым ядром, периодически приходилось работать с глобальными переменными:

Суперглобальные массивы:
- $_SERVER
- $_POST
- $_GET
- $_REQUEST
- и т.д.

Глобальные объекты Битрикс:
- $APPLICATION
- $DB

Ядро D7 использует принципы ООП, и не использует глобальных переменных. Не порождает и не обращается к глобальным переменным. Для того чтобы напрямую не обращаться к глобальным переменным в D7 есть такие понятия как приложение и контекст:

### application

    // Получаем объект приложения
    $application = '\Bitrix\Main\Application::getInstance()';

### context

    // Получили объект контекста
    $context = $application->getContext();

    // Одновременно объект + контекст
    $context = '\Bitrix\Main\Application::getContext()';

### server

    // Получаем объект, содержащий серверные данные
    $server = $context->getServer();

    // Путь до корня сайта
    $server->getDocumentRoot();

Получаем любую переменную суперглобального массива $_SERVER:

    // $_SERVER[HTTP_X_REAL_IP]
    $server->get('HTTP_X_REAL_IP');

### request

    // Получаем объект содержащий данные запроса (POST и GET)
    $request = $context->getRequest();

    $request['parameter'];      // так
    $request->get('parameter'); // или так

Открываем страницу с кодом, добавляем в URL `?parameter=5` или другое число строку.  
Также можно получить отдельно POST или GET параметры, COOKIE и т.д.

### Особенности использования глобальных переменных
Зачем отказались от глоабльных переменных:
- используя глобальные переменные вы сильно связываете свой код
- код должен быть разделен на блоки и отвечать за ту или иную область (ООП позволяет это делать):
  - класс, группа классов объединённых по смыслу, которые взаимодействуют между собой
- глобальные переменные доступны всем классам и методам и могут изменяться в любом из них и найти ошибку связанную с глобальной переменной будет тяжело
- глобальную переменно случайно можно назвать таким же именем, как это сделал другой разработчик
  - или можно случайно назначить какоей либо значение суперглобальному массиву

## Языковые файлы и констатнты
Языковые файлы в новом ядре загружаются не сразу. Файлы из папки lang не подключаются одновременно с подключением компонента, шаблона и т.п. Они загружаются при первом запросе языковой фразы. Языковые файлы шаблона не загружаются до тех пор пока не будет в коде встречен вызов метода GetMessage().

Языковые файлы должны быть уникальны по индексу массива, для всего файла целиком.

## Исключения
В новом ядре D7 используется механизм исключений Exceptions.

Исключительная ситуация (в которой может быть выброшено исключение) - это не типичная ситуация, при которой не имеет смысла продолжать выполнение базового алгоритма.

Что такое исключительная ситуация:
- если пользователь отправил форму с пустым полем, это не исключительная ситуация, это ожидаемая ситуация корорая должна быть обработана
- если при вызове метода API, для изменения элемента инфоблока, был указан пустой ID элемента, это исключительная ситуация, это не ожидаемая ситуация и продолжать изменение элемента не имеет смысла
- если метод ожидает ID пользователся, а передана строка, это исключительная ситуация, так как метод не знает что делать со строкой в данном случае

Все исключени Битрикса наследуются от встроенного PHP класса `\Exception`, присутствует в PHP с версии 5.  

Иерархия исключений Битрикса, целый набор классов Битрикса, унаследованных от `\Exception`, для разных ситуаций:
https://dev.1c-bitrix.ru/learning/course/index.php?COURSE_ID=43&LESSON_ID=2803

При реализации своего кода, если происходит внештатная ситуация, можно выбросить одно из доступных исключений в Битриксе, которое заранее было определено для той или иной ситуации, или же унаследоваться от одного из них, создать своё исключение.

Пример исключения:

    throw new \Bitrix\Main\ArgumentTypeException('Аргумент, который генерирует исключение (имя аргумента)', 'Тип аргумента');

В файле `.settings.php` в разделе `exception_handling` можно включить или выключить режим отладки `'debug'=>false`. При false не будет показывать детали ошибки.

Мы можем перехватить исключение, которое было выброшено нами или сторонним кодом, используя конструкцию `try catch`:

    try {
      // Тут обычно находится выполняемый код
      throw new \Bitrix\Main\ArgumentTypeException('Аргумент, который генерирует исключение', 'Тип аргумента');
    } catch( Exception $e ) {
      echo 'Перехваченное исключение';
    }

Получение дополнительной информации об исключении:
Свойства и методы класса Exception: https://www.php.net/manual/ru/class.exception.php  
Также есть методы созданные Битриком, пример: `$e->getRequiredType()` (получаем тип аргумента, который привел к исключению).
